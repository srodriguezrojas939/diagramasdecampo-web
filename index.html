<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagrama de campo vectorial - Raiz Cuadrada</title>

    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/nerdamer.core.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/Algebra.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/Calculus.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/Solve.js"></script>
    <script src="https://unpkg.com/d3@3/d3.min.js"></script>
    <script src="https://unpkg.com/function-plot/dist/function-plot.js"></script>
     <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
<script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap');

        .fade-in { opacity: 0; transform: translateY(25px); animation: fadeUp 0.9s ease forwards; }
        @keyframes fadeUp { to { opacity: 1; transform: translateY(0); } }

        body { background: white; display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; padding: 20px; box-sizing: border-box; font-family: 'Open Sans', sans-serif; }

        .calculadora-moderna {
            max-width: 650px; width: 100%; padding: 40px 30px;
            background: #F2F2F2; border-radius: 35px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.05);
            box-sizing: border-box;
        }

        .header-section { text-align: center; margin-bottom: 25px; }
        .header-section h1 { font-size: 28px; margin: 0; font-family: 'Playfair Display', serif; }
        .header-section p { font-size: 18px; font-weight: 600; color: #333; font-family: 'Playfair Display', serif; margin: 5px 0; }

        label { display: block; font-size: 11px; margin-bottom: 6px; margin-left: 12px; font-weight: 700; text-transform: uppercase; color: #666; letter-spacing: 0.5px; }

        .input-group { display: flex; gap: 10px; margin-bottom: 15px; align-items: center; }

        input[type="text"], input[type="number"] {
            font-size: 14px; padding: 12px 18px; border: 1px solid #ccc; border-radius: 25px;
            background: white; width: 100%; box-sizing: border-box; outline: none;
        }

        /* Estilo Color Picker Cuadrado */
        .color-picker-container {
            width: 45px; height: 45px; flex-shrink: 0; position: relative;
            border-radius: 12px; overflow: hidden; border: 2px solid white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        input[type="color"] {
            position: absolute; top: -10px; left: -10px; width: 70px; height: 70px;
            cursor: pointer; border: none; padding: 0; background: none;
        }

        /* Sliders */
        input[type=range] { -webkit-appearance: none; background: transparent; padding: 0; border: none; width: 100%; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 6px; cursor: pointer; background: #ddd; border-radius: 3px; }
        input[type=range]::-webkit-slider-thumb { height: 18px; width: 18px; border-radius: 50%; background: black; cursor: pointer; -webkit-appearance: none; margin-top: -6px; }

        .botones-container { display: flex; flex-direction: column; gap: 10px; margin-top: 15px; }
        .boton-estilo {
            display: flex; align-items: center; justify-content: center;
            background: white; border: 1px solid #ccc; border-radius: 30px;
            padding: 12px; cursor: pointer; font-weight: 700; font-size: 13px; transition: 0.3s;
            color: black; text-decoration: none;
        }
        .boton-principal { background: black; color: white; border: none; }

        #contenedor-grafica {
            margin-top: 25px; background: white; border-radius: 25px;
            padding: 10px; border: 1px solid #ddd; overflow: hidden;
            display: flex; justify-content: center; position: relative;
        }
        #grafica { width: 100%; }
        #info-box { text-align: center; margin-top: 10px; font-size: 12px; color: #666; font-weight: 600; }

        /* PILLS NAVIGATION */
        .pills-nav-container {
            background: #e4e4e4; padding: 6px; border-radius: 40px;
            display: flex; justify-content: space-between; gap: 3px; margin-top: 25px;
            border: 1px solid #ccc;
        }
        .pill-btn {
            background: transparent; border: none; padding: 10px; border-radius: 30px;
            font-size: 11px; font-weight: 700; color: #666; cursor: pointer; 
            transition: 0.3s; flex: 1; text-transform: uppercase;
        }
        .pill-btn.active { background: white; color: black; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }

        .tab-content { display: none; margin-top: 20px; }
        .tab-content.active { display: block; }

        .symbols-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
        }
        .sym-card {
            background: white; border-radius: 20px; padding: 15px 10px;
            text-align: center; cursor: pointer; transition: 0.2s;
            border: 1px solid #ccc; display: flex; flex-direction: column; min-height: 70px; justify-content: center;
        }
        .sym-card span { font-size: 13px; font-weight: 700; color: #000; }
        .sym-card small { font-size: 10px; color: #999; text-transform: uppercase; margin-top: 4px; }

        .guia-uso-container { background: white; border-radius: 25px; padding: 25px; color: #444; border: 1px solid #ccc; font-size: 14px; }
        .guia-uso-container h3 { font-family: 'Playfair Display', serif; margin-top: 0; }
        .code-box { background: #f8f8f8; padding: 10px; border-radius: 10px; font-family: monospace; font-size: 12px; margin: 10px 0; border-left: 3px solid black; }

        @media (max-width: 500px) { .header-section h1 { font-size: 22px; } .symbols-grid { grid-template-columns: 1fr 1fr; } }
        
        /* Sliders Modernos */
.modern-slider {
    -webkit-appearance: none;
    width: 100%;
    height: 4px;
    background: #efefef;
    border-radius: 2px;
    outline: none;
}

.modern-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    background: #000;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid #fff;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    transition: transform 0.2s ease;
}

.modern-slider::-webkit-slider-thumb:hover {
    transform: scale(1.15);
}

/* Switch Estético */
.switch-estetico {
    position: relative;
    display: inline-block;
    width: 44px;
    height: 24px;
}

.switch-estetico input { opacity: 0; width: 0; height: 0; }

.slider-toggle {
    position: absolute;
    cursor: pointer;
    top: 0; left: 0; right: 0; bottom: 0;
    background-color: #e0e0e0;
    transition: .4s;
    border-radius: 24px;
}

.slider-toggle:before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

input:checked + .slider-toggle { background-color: #000; }
input:checked + .slider-toggle:before { transform: translateX(20px); }

.input-coord-minimal {
    border: none;
    background: transparent;
    font-size: 12px;
    font-weight: 700;
    color: #363636;
    outline: none;
    width: 100%;
}

/* Brillo y suavidad para las partículas */
.vector-particle {
    filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.9)); /* Brillo central */
    stroke: rgba(255, 255, 255, 0.4); /* Un pequeño borde sutil */
    stroke-width: 0.5px;
    transition: r 0.2s ease, opacity 0.3s ease; /* Para que el cambio de tamaño sea fluido */
    pointer-events: none; /* Para que no interfieran con el mouse */
}
.photon-particle {
    filter: url(#photon-glow);
    stroke: #2e2e2e;
    stroke-width: 2px;
    stroke-opacity: 0.8;
    /* Esto crea la ilusión de estela al suavizar el movimiento entre frames */
    transition: all 0.1s linear; 
}

    </style>
</head>
<body>

<svg width="0" height="0" style="position:absolute;">
  <defs>
    <filter id="photon-glow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
      <feMerge>
        <feMergeNode in="coloredBlur"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
    
    <filter id="estela" x="-20%" y="-20%" width="140%" height="140%">
        <feGaussianBlur in="SourceGraphic" stdDeviation="1.5" />
    </filter>
  </defs>
</svg>

<div class="fade-in" style="width: 100%; display: flex; justify-content: center;">
    <div class="calculadora-moderna">
        <div class="header-section">
            <h1>Diagrama de campo vectorial</h1>
            <p>√(Raiz) Cuadrada²</p>
        </div>

        <div class="input-container">
            <label>Componente P(x, y) [Horizontal]</label>
            <div class="input-group">
                <input id="input-p" type="text" value="-y">
                <div class="color-picker-container">
                    <input type="color" id="color-start" value="#0000ff">
                </div>
            </div>
            
            <label>Componente Q(x, y) [Vertical]</label>
            <div class="input-group">
                <input id="input-q" type="text" value="x">
                <div class="color-picker-container">
                    <input type="color" id="color-end" value="#ff0000">
                </div>
            </div>

<label>Componente R(x, y, z) [Profundidad - Opcional]</label>
<div class="input-group">
    <input id="input-r" type="text" placeholder="Ej: sin(z) o dejar vacío para 2D">
    <div class="color-picker-container">
        <input type="color" id="color-z" value="#00ff00">
    </div>
</div>

        <div style="background: white; border-radius: 28px; padding: 25px; border: 1px solid #e0e0e0; margin-top: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.02);">
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 25px; margin-bottom: 20px;">
        <div>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <label style="margin: 0; font-size: 10px; letter-spacing: 0.8px; color: #888;">DENSIDAD</label>
            </div>
            <input type="range" id="densidad" min="10" max="40" value="22" oninput="procesar()" class="modern-slider">
        </div>

        <div>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <label style="margin: 0; font-size: 10px; letter-spacing: 0.8px; color: #888;">ESCALA FLECHAS</label>
            </div>
            <input type="range" id="magnitud" min="0.1" max="2.0" step="0.1" value="0.8" oninput="procesar()" class="modern-slider">
        </div>
        
        <div>
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <label style="margin: 0; font-size: 10px; letter-spacing: 0.8px; color: #888;">ZOOM / RANGO</label>
    </div>
    <input type="range" id="input-range" min="2" max="50" value="10" oninput="procesar()" class="modern-slider">
</div>

    </div>

    <div style="height: 1px; background: #f0f0f0; margin-bottom: 15px;"></div>

    <div style="display: flex; align-items: center; justify-content: space-between;">
        <div>
            <span style="display: block; font-size: 12px; font-weight: 700; color: #333;">Normalización Unitaria</span>
            <span style="display: block; font-size: 10px; color: #999; text-transform: uppercase; margin-top: 2px;">Mantener flechas con longitud constante</span>
        </div>
        <label class="switch-estetico">
            <input type="checkbox" id="check-normalizar" checked onchange="procesar()">
            <span class="slider-toggle"></span>
        </label>
    </div>
</div>
        </div>

        <div class="botones-container">
            <button onclick="procesar()" class="boton-estilo boton-principal">Actualizar Campo</button>
           
        </div>

<div style="display: flex; justify-content: center;">
    <div class="pills-nav-container" style="display: inline-flex; width: auto; gap: 8px; padding: 6px 12px; align-items: center; justify-content: center; background: #e4e4e4; border-radius: 40px; border: 1px solid #ccc; overflow: visible;">
        
        <button id="btn-animar" class="pill-static" title="Animación de partículas" style="flex: 0 0 45px; height: 38px; display: flex; align-items: center; justify-content: center; background: white; border-radius: 20px; border: none; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.05);">
            <i data-lucide="play" id="icon-animar" style="width: 18px; height: 18px; color: black;"></i>
        </button>

        <button id="btn-streamlines" class="pill-static" title="Líneas de corriente" style="flex: 0 0 45px; height: 38px; display: flex; align-items: center; justify-content: center; background: white; border-radius: 20px; border: none; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.05); transition: 0.3s;">
            <i data-lucide="wind" id="icon-stream" style="width: 18px; height: 18px; color: black;"></i>
          
 <button id="btn-visor" class="pill-static" title="Ocultar/Mostrar flechas" style="flex: 0 0 45px; height: 38px; display: flex; align-items: center; justify-content: center; background: white; border-radius: 20px; border: none; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.05); transition: 0.3s;">
            <i data-lucide="eye" id="icon-visor" style="width: 18px; height: 18px; color: black;"></i>
        </button>

        <div class="pill-static" style="display: flex; align-items: center; gap: 10px; padding: 0 15px; height: 38px; min-width: 160px; justify-content: center; background: white; border-radius: 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.05);">
            <i data-lucide="target" style="width: 18px; height: 18px; color: #888;"></i>
            <div style="display: flex; flex-direction: column; justify-content: center;">
                <span style="font-size: 8px; color: #999; font-weight: 800; text-transform: uppercase; line-height: 1;">Punto Crítico</span>
                <input type="text" id="coordSola" value="Buscando..." class="input-coord-minimal" readonly style="width: 100px; border: none; background: transparent; font-size: 13px; font-weight: 700; color: #363636; outline: none; padding: 0;">
            </div>
        </div>
    </div>
</div>

<div style="width: 80%; height: 1px; background: linear-gradient(to right, transparent, #ddd, transparent); margin: 0px auto;"></div>
        <div id="contenedor-grafica">
            <div id="grafica"></div>
        </div>
        <div id="info-box">Colores interpolados por magnitud del vector</div>
        
     <div id="leyenda-color-container" style="margin-top: 15px; display: none; padding: 0 10px;">
    <div id="barra-gradiente" style="
        height: 12px; 
        width: 100%; 
        border-radius: 6px; 
        background: linear-gradient(to right, #ccc, #000);
        margin-bottom: 5px;
        border: 1px solid rgba(0,0,0,0.1);">
    </div>
    <div id="escala-valores" style="display: flex; justify-content: space-between; font-size: 11px; color: #444; font-family: 'Open Sans', sans-serif; font-weight: 600;">
        <span id="val-0">0</span>
        <span id="val-25"></span>
        <span id="val-50"></span>
        <span id="val-75"></span>
        <span id="val-100"></span>
    </div>



        <div class="pills-nav-container">
            <button class="pill-btn active" onclick="showTab('ejemplos', this)">Ejemplos</button>
            <button class="pill-btn" onclick="showTab('tab-simbolos', this)">Simbolos</button>
            <button class="pill-btn" onclick="showTab('guia', this)">Guia</button>
        </div>

        <div id="ejemplos" class="tab-content active"><div class="symbols-grid" id="grid-ejemplos"></div></div>
        <div id="tab-simbolos" class="tab-content"><div class="symbols-grid" id="grid-simbolos"></div></div>
       <div id="guia" class="tab-content" style="line-height: 1.6; color: #333; background: white; border: 1px solid #ccc; padding: 40px; border-radius: 40px; text-align: left; margin-top: 20px;">
    
    <h2 style="font-family: 'Playfair Display', serif; font-size: 36px; margin-bottom: 25px; border-bottom: 1px solid #eee; padding-bottom: 15px;">Guia de usos.</h2>
    
    <p>Esta herramienta permite representar magnitudes y direcciones de fuerzas en un plano bidimensional a través de vectores posicionados en una malla de coordenadas.</p>

    <h3 style="font-size: 24px; margin-top: 35px; font-weight: bold;">1. Componentes del Campo</h3>
    <p>Un campo vectorial asigna un vector <strong>F(x,y) = P i + Q j</strong> a cada punto del plano. Para graficarlo, debe definir el comportamiento de sus dos componentes principales:</p>
    
    <div style="border: 1px solid #ccc; border-radius: 15px; overflow: hidden; margin: 20px 0;">
        <table style="width: 100%; border-collapse: collapse;">
            <thead>
                <tr style="background: #f8f8f8; border-bottom: 1px solid #ccc;">
                    <th style="padding: 12px; text-align: left; border-right: 1px solid #ccc;">Componente</th>
                    <th style="padding: 12px; text-align: left;">Descripción funcional</th>
                </tr>
            </thead>
            <tbody>
                <tr style="border-bottom: 1px solid #ccc;">
                    <td style="padding: 12px; border-right: 1px solid #ccc;"><strong>P (i)</strong></td>
                    <td style="padding: 12px;">Define la fuerza o desplazamiento en el eje <strong>Horizontal</strong>.</td>
                </tr>
                <tr>
                    <td style="padding: 12px; border-right: 1px solid #ccc;"><strong>Q (j)</strong></td>
                    <td style="padding: 12px;">Define la fuerza o desplazamiento en el eje <strong>Vertical</strong>.</td>
                </tr>
            </tbody>
        </table>
    </div>

    <h3 style="font-size: 24px; margin-top: 35px; font-weight: bold;">2. Sintaxis Matemática</h3>
    <p>Utilice las reglas de escritura estándar para que el motor procese las ecuaciones correctamente:</p>
    <ul>
        <li><strong>Potencias:</strong> Se representan con el símbolo <strong>^</strong> (ejemplo: x^2).</li>
        <li><strong>Multiplicación:</strong> Es obligatorio el uso del asterisco <strong>*</strong> (ejemplo: 2*x*y).</li>
        <li><strong>Variables permitidas:</strong> Utilice únicamente <strong>x</strong> y <strong>y</strong> en minúsculas.</li>
        <li><strong>Funciones:</strong> Puede usar comandos como <strong>sin()</strong>, <strong>cos()</strong>, <strong>exp()</strong>, <strong>sqrt()</strong>, <strong>abs()</strong> y <strong>log()</strong>.</li>
    </ul>

    <h3 style="font-size: 24px; margin-top: 35px; font-weight: bold;">3. Interpretación Visual y Colores</h3>
    <p>El sistema utiliza un código visual basado en la <strong>magnitud</strong> (largo) del vector:</p>
    <ul>
        <li><strong>Gradiente:</strong> El color de las flechas transita desde el primer selector de color hasta el segundo según la intensidad de la fuerza en ese punto.</li>
        <li><strong>Relación:</strong> Los vectores más cortos representan una magnitud menor (primer color), mientras que los más largos indican mayor fuerza (segundo color).</li>
    </ul>

    

    <h3 style="font-size: 24px; margin-top: 35px; font-weight: bold;">4. Control de la Visualización</h3>
    <p>Para analizar el comportamiento del flujo o campo de fuerzas, puede ajustar los siguientes parámetros:</p>
    <ul>
        <li><strong>Densidad:</strong> Controla la cantidad de flechas presentes en la cuadrícula.</li>
        <li><strong>Escala:</strong> Ajusta el tamaño visual de los vectores para evitar que se solapen entre sí.</li>
        <li><strong>Rango:</strong> Define el límite de los ejes X e Y para visualizar áreas específicas del plano.</li>
    </ul>

    <h3 style="font-size: 24px; margin-top: 35px; font-weight: bold;">5. Interacción con el Lienzo</h3>
    <ul>
        <li><strong>Navegación:</strong> Arrastre con el clic izquierdo para desplazarse por el plano de coordenadas.</li>
        <li><strong>Zoom:</strong> Utilice la rueda del ratón para acercar o alejar la vista.</li>
        <li><strong>Captura:</strong> El botón de "Descargar PNG" guardará una imagen de alta resolución de la configuración actual de su campo vectorial.</li>
    </ul>

    <div style="border: 1px solid #ccc; padding: 25px; border-radius: 20px; margin-top: 35px; background: #fafafa; font-style: italic;">
        <strong>Nota técnica:</strong>
        <p style="margin-top: 10px;">En física, este tipo de representaciones son esenciales para visualizar fenómenos como el flujo de fluidos, campos eléctricos o gradientes de temperatura. Experimente con funciones combinadas para observar puntos de convergencia (sumideros) o divergencia (fuentes).</p>
    </div>

</div>

    </div>
</div>

<canvas id="canvas-export" style="display:none;"></canvas>

<script>
    
   let funciones3D = { p: null, q: null, r: null }; // Necesaria para guardar las formulas
let particulas3D = [];
const NUM_PARTICULAS_3D = 200;

let flechasVisibles = true;

document.getElementById('btn-visor').addEventListener('click', function() {
    flechasVisibles = !flechasVisibles;
    
    // Cambiar ícono y color del botón
    const icon = document.getElementById('icon-visor');
    if (flechasVisibles) {
        icon.setAttribute('data-lucide', 'eye');
        this.style.background = "white";
        icon.style.color = "black";
    } else {
        icon.setAttribute('data-lucide', 'eye-off');
        this.style.background = "#000";
        icon.style.color = "white";
    }
    lucide.createIcons(); // Refrescar íconos de Lucide
    
    procesar(); // Refrescar ambas gráficas
});
    let timeoutProcesar;
function debounceProcesar() {
    clearTimeout(timeoutProcesar);
    timeoutProcesar = setTimeout(procesar, 100); // Espera 100ms de calma para graficar
}

const dataTabs = {
    ejemplos: [
        { s: '-y | x', t: 'VÓRTICE / ROTACIÓN' },
        { s: 'x | y', t: 'FUENTE / REPULSIÓN' },
        { s: '-x | -y', t: 'SUMIDERO / ATRACCIÓN' },
        { s: 'y | sin(x)', t: 'ONDAS DE CORTE' },
        { s: 'x-y | x+y', t: 'ESPIRAL EXPANSIVA' },
        { s: 'sin(y) | sin(x)', t: 'CAMPO PERIÓDICO' },
        { s: '1 | cos(x)', t: 'FLUJO UNIDIRECCIONAL' },
        { s: 'y | -x', t: 'ROTACIÓN HORARIA' }
    ],
    simbolos: [
        { s: '(', t: 'ABRIR' }, { s: ')', t: 'CERRAR' }, { s: '+', t: 'SUMA' }, { s: '-', t: 'RESTA' },
        { s: '*', t: 'MULT.' }, { s: '/', t: 'DIV.' }, { s: '^', t: 'POTENCIA' }, { s: 'sqrt()', t: 'RAÍZ' },
        { s: 'x', t: 'VAR X' }, { s: 'y', t: 'VAR Y' }, { s: 'pi', t: 'PI' }, { s: 'e', t: 'EULER' }
    ]
};

function renderGrids() {
    document.getElementById('grid-ejemplos').innerHTML = dataTabs.ejemplos.map(item => `
        <div class="sym-card" onclick="aplicarEjemplo('${item.s}')">
            <span>${item.s}</span>
            <small>${item.t}</small>
        </div>
    `).join('');

    document.getElementById('grid-simbolos').innerHTML = dataTabs.simbolos.map(item => `
        <div class="sym-card" onclick="insertarSimbolo('${item.s}')">
            <span>${item.s}</span>
            <small>${item.t}</small>
        </div>
    `).join('');
}

function aplicarEjemplo(val) {
    const [p, q] = val.split(' | ');
    document.getElementById('input-p').value = p.trim();
    document.getElementById('input-q').value = q.trim();
    procesar();
}

function insertarSimbolo(val) {
    const input = document.activeElement.tagName === 'INPUT' ? document.activeElement : document.getElementById('input-p');
    input.value += val;
    input.focus();
}

function showTab(id, btn) {
    document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.pill-btn').forEach(b => b.classList.remove('active'));
    document.getElementById(id).classList.add('active');
    btn.classList.add('active');
}

function hexToRgb(hex) {
    const r = parseInt(hex.slice(1,3), 16), g = parseInt(hex.slice(3,5), 16), b = parseInt(hex.slice(5,7), 16);
    return {r, g, b};
}

function interpolarColor(c1, c2, valor) {
    const p = Math.max(0, Math.min(1, valor));
    const r = Math.round(c1.r + (c2.r - c1.r) * p);
    const g = Math.round(c1.g + (c2.g - c1.g) * p);
    const b = Math.round(c1.b + (c2.b - c1.b) * p);
    return `rgb(${r},${g},${b})`;
}

window.onload = () => { renderGrids(); procesar(); };
window.addEventListener('resize', procesar);

function procesar(puntosExtra = null) {
    const pExpr = document.getElementById('input-p').value;
    const qExpr = document.getElementById('input-q').value;
    const rExpr = document.getElementById('input-r').value; 
    
    const containerGrafica = document.getElementById('grafica'); 
    
    // --- LÓGICA DE DETECCIÓN 3D ---
    if (rExpr && rExpr.trim() !== "") { 
        // 1. Detenemos animaciones 2D si estuvieran activas
        if (animacionActiva) { 
            animacionActiva = false; 
            cancelAnimationFrame(animationId); 
            document.getElementById('icon-animar').setAttribute('data-lucide', 'play'); 
            lucide.createIcons(); 
        }
        
        // 2. Limpieza total para que Plotly tome el control
        containerGrafica.innerHTML = '';  
        containerGrafica.style.display = 'block'; 
        
        // 3. Renderizamos y salimos
        renderizar3D(pExpr, qExpr, rExpr); 
        return; 
        
    } else {
        // --- LIMPIEZA PARA VOLVER A 2D ---
        if (window.Plotly) {
            Plotly.purge(containerGrafica);
        }
    }

    // --- LÓGICA 2D (Solo se ejecuta si no hay R) ---
    const nSteps = parseInt(document.getElementById('densidad').value);
    const mScale = parseFloat(document.getElementById('magnitud').value);
    const colorStart = hexToRgb(document.getElementById('color-start').value);
    const colorEnd = hexToRgb(document.getElementById('color-end').value);
    const normalizar = document.getElementById('check-normalizar').checked;
    const viewRange = parseFloat(document.getElementById('input-range').value) || 10;
    
    const container = document.getElementById('contenedor-grafica');
    const width = container.offsetWidth - 20;

    try {
        const pFunc = nerdamer(pExpr).buildFunction(['x', 'y']);
        const qFunc = nerdamer(qExpr).buildFunction(['x', 'y']);

        // Asignación para que el motor de animación vea las funciones actuales
        pFuncGlobal = pFunc; 
        qFuncGlobal = qFunc;

        let vectorData = [];
        const stepSize = (viewRange * 2) / nSteps;
        let calculos = [];

        for (let i = -viewRange; i <= viewRange; i += stepSize) {
            for (let j = -viewRange; j <= viewRange; j += stepSize) {
                try {
                    let vx = pFunc(i, j);
                    let vy = qFunc(i, j);
                    let mag = Math.sqrt(vx * vx + vy * vy);
                    if (!isNaN(mag) && isFinite(mag)) {
                        calculos.push({ i, j, vx, vy, mag });
                    }
                } catch (e) {}
            }
        }

        // --- CÁLCULO DE MAGNITUD Y ACTUALIZACIÓN DE LEYENDA ---
        const maxMag = Math.max(...calculos.map(c => c.mag)) || 1;
        const c1 = document.getElementById('color-start').value;
        const c2 = document.getElementById('color-end').value;
        
        // Llamada a la escala numérica
        if (typeof actualizarEscalaNumerica === 'function') {
            actualizarEscalaNumerica(maxMag, c1, c2);
        }

        // Actualizar la visual de la leyenda inferior
        const leyenda = document.getElementById('leyenda-color-container');
        const barra = document.getElementById('barra-gradiente');
        if (leyenda && barra) {
            leyenda.style.display = 'block';
            barra.style.background = `linear-gradient(to right, ${c1}, ${c2})`;
            const labelMax = document.getElementById('valor-max-leyenda');
            if (labelMax) labelMax.innerText = `Fuerte (${maxMag.toFixed(2)})`;
        }

        // --- PUNTO CRÍTICO ---
        const critico = calculos.length > 0 ? calculos.reduce((min, p) => p.mag < min.mag ? p : min, calculos[0]) : null;
        const inputCoord = document.getElementById('coordSola');
        if (inputCoord) {
            if (critico && (critico.mag / maxMag) < 0.1) {
                inputCoord.value = `${critico.i.toFixed(1)}, ${critico.j.toFixed(1)}`;
            } else {
                inputCoord.value = "No detectado";
            }
        }

        // --- CONSTRUCCIÓN DE FLECHAS ---
        if (flechasVisibles) { 

        calculos.forEach(p => {
            // TUS CÁLCULOS INTACTOS
            const factorEscala = normalizar ? 1 : (p.mag / maxMag);
            const nvx = (p.vx / (p.mag + 0.0001)) * mScale * factorEscala;
            const nvy = (p.vy / (p.mag + 0.0001)) * mScale * factorEscala;
            const color = interpolarColor(colorStart, colorEnd, p.mag / maxMag);
            const xF = p.i + nvx, yF = p.j + nvy;
            const angle = Math.atan2(nvy, nvx);
            const pL = (mScale * 0.35) * (normalizar ? 1 : Math.max(0.2, factorEscala));
            
            vectorData.push({
                points: [
                    [p.i, p.j], [xF, yF], 
                    [xF - pL * Math.cos(angle - 0.5), yF - pL * Math.sin(angle - 0.5)], 
                    [xF, yF], 
                    [xF - pL * Math.cos(angle + 0.5), yF - pL * Math.sin(angle + 0.5)]
                ],
                fnType: 'points',
                graphType: 'polyline',
                color: color,
                attr: { 'stroke-width': 1.8 }
            });
        });

    }

        const lineasFlujo = typeof calcularStreamlines === 'function' ? calcularStreamlines(pFunc, qFunc, viewRange) : [];

        // --- RENDERIZADO FINAL 2D ---
        functionPlot({
            target: "#grafica",
            width: width,
            height: width * 0.8,
            grid: true,
            xAxis: { domain: [-viewRange * 1.1, viewRange * 1.1] },
            yAxis: { domain: [-viewRange * 0.9, viewRange * 0.9] },
            data: [
                ...lineasFlujo,      
                ...vectorData,       
                ...(typeof puntosExtra !== 'undefined' && puntosExtra ? [puntosExtra] : []) 
            ]
        });

    } catch (e) { 
        console.error("Error matemático:", e); 
    }
}


function exportarImagen() {
    const svgElement = document.querySelector('#grafica svg');
    const canvas = document.getElementById('canvas-export');
    const ctx = canvas.getContext('2d');
    const svgData = new XMLSerializer().serializeToString(svgElement);
    const img = new Image();
    const svgSize = svgElement.getBoundingClientRect();
    canvas.width = svgSize.width * 2; canvas.height = svgSize.height * 2;
    img.onload = function() {
        ctx.fillStyle = "white"; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        ctx.font = "bold 42px 'Playfair Display'"; ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.textAlign = "right"; ctx.fillText("√(Raiz) Cuadrada²", canvas.width - 50, canvas.height - 50);
        const link = document.createElement('a');
        link.download = 'campo-vectorial-raiz-cuadrada.png';
        link.href = canvas.toDataURL('image/png'); link.click();
    };
    img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
}

let animacionActiva = false;
let particulas = [];
const numParticulas = 80; // Cantidad de partículas
let animationId;

// Inicializar Lucide al cargar
window.addEventListener('load', () => {
    lucide.createIcons();
    setupAnimacion();
});

function setupAnimacion() {
    const btn = document.getElementById('btn-animar');
    
    btn.addEventListener('click', () => {
        animacionActiva = !animacionActiva;
        const icon = document.getElementById('icon-animar');
        
        if (animacionActiva) {
            // --- ESTADO: REPRODUCIENDO ---
            icon.setAttribute('data-lucide', 'pause');
            btn.classList.add('animando');
            
            // 1. Inicializar 2D (Lógica existente)
            iniciarParticulas();

            // 2. Inicializar 3D (NUEVO BLOQUE)
            const grafica3D = document.getElementById('grafica');
            // Si el contenedor 3D está visible y el arreglo 3D está vacío...
            if (grafica3D && grafica3D.style.display !== 'none' && particulas3D.length === 0) {
                const range = parseFloat(document.getElementById('input-range').value) || 10;
                initParticulas3D(range); // Llenamos las moléculas 3D
            }

            animarLoop(); // Arranca el motor
        } else {
            // --- ESTADO: PAUSADO ---
            icon.setAttribute('data-lucide', 'play');
            btn.classList.remove('animando');
            cancelAnimationFrame(animationId);
            limpiarParticulas();
        }
        
        lucide.createIcons(); // Refrescar icono
    });
}

function iniciarParticulas() {
    particulas = [];
    // Obtenemos el rango actual para distribuir las partículas
    const currentRange = parseFloat(document.getElementById('input-range').value) || 10;
    
    for (let i = 0; i < numParticulas; i++) {
        particulas.push({
            x: (Math.random() * currentRange * 2) - currentRange, 
            y: (Math.random() * currentRange * 2) - currentRange,
            vida: Math.random() * 100
        });
    }
}


function animarLoop() {
    if (!animacionActiva) return;

    const currentRange = parseFloat(document.getElementById('input-range').value) || 10;
    const dt = 0.05; // Paso de tiempo

    // --- LÓGICA 2D (La que ya tenías) ---
    // Verificamos si las funciones globales 2D existen (pFuncGlobal, qFuncGlobal)
    // ... (Tu código existente para partículas.forEach en 2D) ...
    if (typeof pFuncGlobal !== 'undefined' && typeof qFuncGlobal !== 'undefined') {
         // Tu lógica actual de 2D...
         particulas.forEach(p => {
             // ... cálculos 2D ...
             let vx = pFuncGlobal(p.x, p.y);
             let vy = qFuncGlobal(p.x, p.y);
             // ... actualización posición 2D ...
             p.x += vx * 0.02; // Ejemplo simplificado
             p.y += vy * 0.02;
             // ... reinicio si sale del rango ...
             if(Math.abs(p.x) > currentRange || Math.abs(p.y) > currentRange) {
                 p.x = (Math.random()*2-1)*currentRange;
                 p.y = (Math.random()*2-1)*currentRange;
             }
         });
         dibujarParticulas(); // Render 2D
    }

    // --- LÓGICA 3D (NUEVA) ---
    const grafica3D = document.getElementById('grafica');
    // Solo calculamos si la gráfica 3D es visible y tenemos funciones cargadas
    if (grafica3D && grafica3D.style.display !== 'none' && funciones3D.p) {
        
        let px = [], py = [], pz = []; // Arrays para Plotly

        particulas3D.forEach(p => {
            // Calcular velocidad en 3D
            let vx = funciones3D.p(p.x, p.y, p.z);
            let vy = funciones3D.q(p.x, p.y, p.z);
            let vz = funciones3D.r(p.x, p.y, p.z);

            // Limite de velocidad para que no salgan disparadas
            const speed = Math.sqrt(vx*vx + vy*vy + vz*vz);
            if (speed > currentRange) { 
                const factor = currentRange / speed;
                vx *= factor; vy *= factor; vz *= factor;
            }

            // Mover
            p.x += vx * dt;
            p.y += vy * dt;
            p.z += vz * dt;
            p.vida -= 0.5;

            // Reiniciar si salen del cubo o mueren
            if (Math.abs(p.x) > currentRange || Math.abs(p.y) > currentRange || Math.abs(p.z) > currentRange || p.vida <= 0) {
                p.x = (Math.random() * 2 - 1) * currentRange;
                p.y = (Math.random() * 2 - 1) * currentRange;
                p.z = (Math.random() * 2 - 1) * currentRange;
                p.vida = 100;
            }

            px.push(p.x);
            py.push(p.y);
            pz.push(p.z);
        });

        if (typeof window.indiceMoleculas3D === 'number') {
    Plotly.restyle('grafica', {
        x: [px],
        y: [py],
        z: [pz]
    }, [window.indiceMoleculas3D]);
}

    }

    animationId = requestAnimationFrame(animarLoop);
}


function dibujarParticulas() {
    const currentRange = parseFloat(document.getElementById('input-range').value) || 10;

    const dataParticulas = {
        points: particulas.map(p => [p.x, p.y]),
        fnType: 'points',
        graphType: 'scatter',
        color: '#ffffff', // Núcleo blanco brillante
        attr: { 
            "r": function(d, i) {
                const p = particulas[i];
                // El fotón brilla más según su velocidad
                const speed = p.lastSpeed || 0;
                const size = 1.2 + (speed / currentRange) * 1.5;
                
                // Efecto de parpadeo suave basado en su vida
                const fade = p.vida < 20 ? (p.vida / 20) : 1;
                return size * fade;
            },
            "class": "photon-particle",
            "opacity": function(d, i) {
                // Desvanecimiento suave al final de la vida
                return particulas[i].vida / 100;
            }
        }
    };

    procesar(dataParticulas); 
}

   
function limpiarParticulas() {
    procesar(); // Simplemente refresca la gráfica sin el layer de partículas
}

let streamlinesActivas = false;

// Configurar el evento del botón en tu window.onload o setup
document.getElementById('btn-streamlines').addEventListener('click', function() {
    streamlinesActivas = !streamlinesActivas;
    this.style.background = streamlinesActivas ? "#000" : "white";
    document.getElementById('icon-stream').style.color = streamlinesActivas ? "white" : "black";
    procesar(); // Refrescar gráfica
});

function calcularStreamlines(pFunc, qFunc, currentRange) {
    if (!streamlinesActivas) return [];
    
    let lineas = [];
    // Ajustamos la densidad de semillas y longitud según el rango visible
    const numSemillas = 14; 
    const pasos = 50; // Más pasos para que las curvas se completen en zooms grandes
    
    // El diferencial de tiempo (dt) debe escalar con el rango para que la línea 
    // no se vea como un punto pequeño cuando te alejas.
    const dt = currentRange * 0.02; 

    // Los bucles ahora usan currentRange en lugar de 10 fijo
    for (let i = -currentRange; i <= currentRange; i += (currentRange * 2) / numSemillas) {
        for (let j = -currentRange; j <= currentRange; j += (currentRange * 2) / numSemillas) {
            let puntosLinea = [];
            let currX = i;
            let currY = j;

            for (let s = 0; s < pasos; s++) {
                puntosLinea.push([currX, currY]);
                
                try {
                    let vx = pFunc(currX, currY);
                    let vy = qFunc(currX, currY);
                    let mag = Math.sqrt(vx * vx + vy * vy);
                    
                    // Evitar división por cero o valores infinitos
                    if (mag < 0.0001 || !isFinite(mag)) break; 

                    // Normalizamos el avance para que la línea siga la dirección del flujo
                    currX += (vx / mag) * dt;
                    currY += (vy / mag) * dt;
                    
                    // Límite de escape: un poco más allá del rango visible para suavidad
                    if (Math.abs(currX) > currentRange * 1.5 || Math.abs(currY) > currentRange * 1.5) break;
                } catch (e) { break; }
            }

            if (puntosLinea.length > 2) {
                lineas.push({
                    points: puntosLinea,
                    fnType: 'points',
                    graphType: 'polyline',
                    color: 'rgba(0,0,0,0.12)', // Un tono un poco más sutil para el fondo
                    attr: { 
                        'stroke-width': 1,
                        'stroke-dasharray': '2,1' // Opcional: estilo punteado profesional
                    }
                });
            }
        }
    }
    return lineas;
}


function renderizar3D(pExpr, qExpr, rExpr) {
    const container = document.getElementById('grafica');
    container.style.display = 'block';
    container.innerHTML = ''; // Limpia el rastro de la 2D
    Plotly.purge('grafica');

    // 1. OBTENER VARIABLES DE LA INTERFAZ PRIMERO
    const range = parseFloat(document.getElementById('input-range').value) || 10;
    const densidad = parseInt(document.getElementById('densidad').value) || 20; 
    const escalaFlechas = parseFloat(document.getElementById('magnitud').value) || 1;
    const c1 = document.getElementById('color-start').value;
    const c2 = document.getElementById('color-end').value;
    const n = Math.max(4, Math.floor(densidad / 2.5)); 

    try {
        const pFunc = nerdamer(pExpr).buildFunction(['x', 'y', 'z']);
        const qFunc = nerdamer(qExpr).buildFunction(['x', 'y', 'z']);
        const rFunc = nerdamer(rExpr).buildFunction(['x', 'y', 'z']);

        // --- CORRECCIÓN CRUCIAL AQUÍ ---
        // Guardamos las funciones en la variable global para que el botón de Play las encuentre
        funciones3D = { p: pFunc, q: qFunc, r: rFunc };
        // -------------------------------

        let x = [], y = [], z = [], u = [], v = [], w = [];
        const step = (range * 2) / n;

        // 2. LLENAR LOS DATOS (Bucle For)
        for (let i = -range; i <= range; i += step) {
            for (let j = -range; j <= range; j += step) {
                for (let k = -range; k <= range; k += step) {
                    x.push(i); y.push(j); z.push(k);
                    u.push(pFunc(i, j, k));
                    v.push(qFunc(i, j, k));
                    w.push(rFunc(i, j, k));
                }
            }
        }

        // 3. CALCULAR MAGNITUDES (Solo ahora que u, v, w tienen datos)
        const magnitudes = u.map((val, idx) => Math.sqrt(val**2 + v[idx]**2 + w[idx]**2));
        const maxMag3D = Math.max(...magnitudes) || 1;
        
        // Actualizar la barra inferior con los números
        actualizarEscalaNumerica(maxMag3D, c1, c2);

        // 4. CONFIGURAR EL OBJETO DATA
        let data = [];

        // 2. Si las flechas están activas, las metemos a la lista
        if (typeof flechasVisibles === 'undefined' || flechasVisibles) {
            data.push({
                type: 'cone',
                x: x, y: y, z: z,
                u: u, v: v, w: w,
                sizemode: 'scaled',
                sizeref: escalaFlechas * 1.5, 
                anchor: 'tail', 
                showscale: false,
                colorscale: [[0, c1], [1, c2]], 
                hoverinfo: 'u+v+w'
            });
        }
        
        if (typeof streamlinesActivas !== 'undefined' && streamlinesActivas) {
            // Generamos puntos de inicio distribuidos por todo el volumen
            let startX = [], startY = [], startZ = [];
            
            // Creamos una malla de puntos en los bordes para "inyectar" viento al cubo
            for (let s = -range; s <= range; s += range) {
                for (let t = -range; t <= range; t += range/2) {
                    // Puntos en las caras X
                    startX.push(s); startY.push(t); startZ.push(t);
                    // Puntos en las caras Y
                    startX.push(t); startY.push(s); startZ.push(t);
                    // Puntos en las caras Z
                    startX.push(t); startY.push(t); startZ.push(s);
                }
            }

            data.push({
                type: 'streamtube',
                x: x, y: y, z: z,
                u: u, v: v, w: w,
                starts: {
                    x: startX,
                    y: startY,
                    z: startZ
                },
                sizeref: 0.05, // Seguimos con hilos delgados
                colorscale: [[0, '#121212'], [1, '#FFFFFF']], // De gris oscuro a blanco
                showscale: false,
                opacity: 0.6,
                maxloop: 5000, // Aumentamos longitud para que crucen todo el cubo
                lighting: { ambient: 1, diffuse: 1 }
            });
        }
        
        // CAPA PARA MOLECULAS (Necesaria para que la animación funcione)
        
        
        const layout = {
            scene: {
                xaxis: { title: 'X' },
                yaxis: { title: 'Y' },
                zaxis: { title: 'Z' },
                aspectmode: 'cube'
            },
            margin: { t: 0, b: 0, l: 0, r: 0 },
            height: 550,
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: 'rgba(0,0,0,0)'
        };

        Plotly.newPlot('grafica', data, layout);
    } catch (e) {
        console.error("Error en render 3D:", e);
    }
}


// Función auxiliar para reiniciar partículas 3D
function initParticulas3D(range) {
    particulas3D = [];
    for(let i=0; i<NUM_PARTICULAS_3D; i++) {
        particulas3D.push({
            x: (Math.random() * 2 - 1) * range,
            y: (Math.random() * 2 - 1) * range,
            z: (Math.random() * 2 - 1) * range,
            vida: Math.random() * 100
        });
    }
}




function actualizarEscalaNumerica(maxMag, c1, c2) {
    const leyenda = document.getElementById('leyenda-color-container');
    const barra = document.getElementById('barra-gradiente');
    
    if (leyenda && barra) {
        leyenda.style.display = 'block';
        barra.style.background = `linear-gradient(to right, ${c1}, ${c2})`;
        
        // Calcular y mostrar valores distribuidos
        document.getElementById('val-0').innerText = "0.00";
        document.getElementById('val-25').innerText = (maxMag * 0.25).toFixed(2);
        document.getElementById('val-50').innerText = (maxMag * 0.50).toFixed(2);
        document.getElementById('val-75').innerText = (maxMag * 0.75).toFixed(2);
        document.getElementById('val-100').innerText = maxMag.toFixed(2);
    }
}


    Plotly.newPlot('grafica', data, layout);


</script>
</body>
</html>
